import{V as C,o as H,p as T,q,G as W,k as O,F as V,i as P,r as D,s as z,t as J,n as B,u as U,c as G,S as K,A as Q,a as X,P as Y,m as Z,W as $}from"./three.module.b50ed5da.js";import{O as ee}from"./OrbitControls.a45ac6e3.js";import{g as te}from"./gemotry.cd6e5826.js";import{S as se}from"./stats.eaeba3ab.js";import{_ as ne,h as ie,z as oe,s as re,t as ae}from"./index.10dd6c38.js";const le=/^[og]\s*(.+)?/,ce=/^mtllib /,he=/^usemtl /,de=/^usemap /,N=new C,S=new C,k=new C,R=new C,v=new C,A=new H;function ue(){const I={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=t!==!1;return}const i=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,n){const a=this._finalize(!1);a&&(a.inherited||a.groupCount<=0)&&this.materials.splice(a.index,1);const m={index:this.materials.length,name:e||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:a!==void 0?a.smooth:this.smooth,groupStart:a!==void 0?a.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(y){const j={index:typeof y=="number"?y:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return j.clone=this.clone.bind(j),j}};return this.materials.push(m),m},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const n=this.currentMaterial();if(n&&n.groupEnd===-1&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),e&&this.materials.length>1)for(let a=this.materials.length-1;a>=0;a--)this.materials[a].groupCount<=0&&this.materials.splice(a,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),n}},i&&i.name&&typeof i.clone=="function"){const e=i.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,t){const i=parseInt(s,10);return(i>=0?i-1:i+t/3)*3},parseNormalIndex:function(s,t){const i=parseInt(s,10);return(i>=0?i-1:i+t/3)*3},parseUVIndex:function(s,t){const i=parseInt(s,10);return(i>=0?i-1:i+t/2)*2},addVertex:function(s,t,i){const e=this.vertices,n=this.object.geometry.vertices;n.push(e[s+0],e[s+1],e[s+2]),n.push(e[t+0],e[t+1],e[t+2]),n.push(e[i+0],e[i+1],e[i+2])},addVertexPoint:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addVertexLine:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addNormal:function(s,t,i){const e=this.normals,n=this.object.geometry.normals;n.push(e[s+0],e[s+1],e[s+2]),n.push(e[t+0],e[t+1],e[t+2]),n.push(e[i+0],e[i+1],e[i+2])},addFaceNormal:function(s,t,i){const e=this.vertices,n=this.object.geometry.normals;N.fromArray(e,s),S.fromArray(e,t),k.fromArray(e,i),v.subVectors(k,S),R.subVectors(N,S),v.cross(R),v.normalize(),n.push(v.x,v.y,v.z),n.push(v.x,v.y,v.z),n.push(v.x,v.y,v.z)},addColor:function(s,t,i){const e=this.colors,n=this.object.geometry.colors;e[s]!==void 0&&n.push(e[s+0],e[s+1],e[s+2]),e[t]!==void 0&&n.push(e[t+0],e[t+1],e[t+2]),e[i]!==void 0&&n.push(e[i+0],e[i+1],e[i+2])},addUV:function(s,t,i){const e=this.uvs,n=this.object.geometry.uvs;n.push(e[s+0],e[s+1]),n.push(e[t+0],e[t+1]),n.push(e[i+0],e[i+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const t=this.uvs;this.object.geometry.uvs.push(t[s+0],t[s+1])},addFace:function(s,t,i,e,n,a,m,y,j){const M=this.vertices.length;let c=this.parseVertexIndex(s,M),d=this.parseVertexIndex(t,M),o=this.parseVertexIndex(i,M);if(this.addVertex(c,d,o),this.addColor(c,d,o),m!==void 0&&m!==""){const r=this.normals.length;c=this.parseNormalIndex(m,r),d=this.parseNormalIndex(y,r),o=this.parseNormalIndex(j,r),this.addNormal(c,d,o)}else this.addFaceNormal(c,d,o);if(e!==void 0&&e!==""){const r=this.uvs.length;c=this.parseUVIndex(e,r),d=this.parseUVIndex(n,r),o=this.parseUVIndex(a,r),this.addUV(c,d,o),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const t=this.vertices.length;for(let i=0,e=s.length;i<e;i++){const n=this.parseVertexIndex(s[i],t);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(s,t){this.object.geometry.type="Line";const i=this.vertices.length,e=this.uvs.length;for(let n=0,a=s.length;n<a;n++)this.addVertexLine(this.parseVertexIndex(s[n],i));for(let n=0,a=t.length;n<a;n++)this.addUVLine(this.parseUVIndex(t[n],e))}};return I.startObject("",!1),I}class me extends T{constructor(s){super(s),this.materials=null}load(s,t,i,e){const n=this,a=new q(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(s,function(m){try{t(n.parse(m))}catch(y){e?e(y):console.error(y),n.manager.itemError(s)}},i,e)}setMaterials(s){return this.materials=s,this}parse(s){const t=new ue;s.indexOf(`\r
`)!==-1&&(s=s.replace(/\r\n/g,`
`)),s.indexOf(`\\
`)!==-1&&(s=s.replace(/\\\n/g,""));const i=s.split(`
`);let e="",n="",a=0,m=[];const y=typeof"".trimLeft=="function";for(let c=0,d=i.length;c<d;c++)if(e=i[c],e=y?e.trimLeft():e.trim(),a=e.length,a!==0&&(n=e.charAt(0),n!=="#"))if(n==="v"){const o=e.split(/\s+/);switch(o[0]){case"v":t.vertices.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3])),o.length>=7?(A.setRGB(parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6])).convertSRGBToLinear(),t.colors.push(A.r,A.g,A.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]));break;case"vt":t.uvs.push(parseFloat(o[1]),parseFloat(o[2]));break}}else if(n==="f"){const r=e.slice(1).trim().split(/\s+/),h=[];for(let f=0,b=r.length;f<b;f++){const u=r[f];if(u.length>0){const p=u.split("/");h.push(p)}}const g=h[0];for(let f=1,b=h.length-1;f<b;f++){const u=h[f],p=h[f+1];t.addFace(g[0],u[0],p[0],g[1],u[1],p[1],g[2],u[2],p[2])}}else if(n==="l"){const o=e.substring(1).trim().split(" ");let r=[];const h=[];if(e.indexOf("/")===-1)r=o;else for(let g=0,f=o.length;g<f;g++){const b=o[g].split("/");b[0]!==""&&r.push(b[0]),b[1]!==""&&h.push(b[1])}t.addLineGeometry(r,h)}else if(n==="p"){const r=e.slice(1).trim().split(" ");t.addPointGeometry(r)}else if((m=le.exec(e))!==null){const o=(" "+m[0].slice(1).trim()).slice(1);t.startObject(o)}else if(he.test(e))t.object.startMaterial(e.substring(7).trim(),t.materialLibraries);else if(ce.test(e))t.materialLibraries.push(e.substring(7).trim());else if(de.test(e))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(n==="s"){if(m=e.split(" "),m.length>1){const r=m[1].trim().toLowerCase();t.object.smooth=r!=="0"&&r!=="off"}else t.object.smooth=!0;const o=t.object.currentMaterial();o&&(o.smooth=t.object.smooth)}else{if(e==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+e+'"')}t.finalize();const j=new W;if(j.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let c=0,d=t.objects.length;c<d;c++){const o=t.objects[c],r=o.geometry,h=o.materials,g=r.type==="Line",f=r.type==="Points";let b=!1;if(r.vertices.length===0)continue;const u=new O;u.setAttribute("position",new V(r.vertices,3)),r.normals.length>0&&u.setAttribute("normal",new V(r.normals,3)),r.colors.length>0&&(b=!0,u.setAttribute("color",new V(r.colors,3))),r.hasUVIndices===!0&&u.setAttribute("uv",new V(r.uvs,2));const p=[];for(let _=0,F=h.length;_<F;_++){const w=h[_],E=w.name+"_"+w.smooth+"_"+b;let l=t.materials[E];if(this.materials!==null){if(l=this.materials.create(w.name),g&&l&&!(l instanceof P)){const L=new P;D.prototype.copy.call(L,l),L.color.copy(l.color),l=L}else if(f&&l&&!(l instanceof z)){const L=new z({size:10,sizeAttenuation:!1});D.prototype.copy.call(L,l),L.color.copy(l.color),L.map=l.map,l=L}}l===void 0&&(g?l=new P:f?l=new z({size:1,sizeAttenuation:!1}):l=new J,l.name=w.name,l.flatShading=!w.smooth,l.vertexColors=b,t.materials[E]=l),p.push(l)}let x;if(p.length>1){for(let _=0,F=h.length;_<F;_++){const w=h[_];u.addGroup(w.groupStart,w.groupCount,_)}g?x=new B(u,p):f?x=new U(u,p):x=new G(u,p)}else g?x=new B(u,p[0]):f?x=new U(u,p[0]):x=new G(u,p[0]);x.name=o.name,j.add(x)}else if(t.vertices.length>0){const c=new z({size:1,sizeAttenuation:!1}),d=new O;d.setAttribute("position",new V(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(d.setAttribute("color",new V(t.colors,3)),c.vertexColors=!0);const o=new U(d,c);j.add(o)}return j}}const fe={id:"obj-loader",class:"obj-loader"},pe=ie({setup(I){let s,t,i;return oe(()=>{const e=document.getElementById("obj-loader")||document.body,n=e.clientWidth,a=e.clientHeight;i=new K,i.position.set(0,0,0);const m=new Q(0,1);i.add(m);const y=new X(16777215,.8);t=new Y(45,n/a,1,1e3),t.position.set(100,100,100),t.lookAt(i.position),t.add(y),i.add(t),new me().load("module/Factory_Unit_00.obj",h=>{console.log(h),i.add(h)},h=>{console.log(h.loaded/h.total*100+"% loaded")},()=>{console.log("An error happened")});const c=new te().createBoxBuffer(25,25,25),d=new B(c,new Z({color:16755200,dashSize:3,gapSize:1}));d.computeLineDistances();const o=new se(e,0);i.add(d),s=new $,s.setClearColor(0),s.setSize(n,a),e.appendChild(s.domElement);const r=()=>{requestAnimationFrame(r),s.render(i,t),o.update()};new ee(t,s.domElement),r()}),(e,n)=>(re(),ae("div",fe))}});var xe=ne(pe,[["__scopeId","data-v-68273a9e"]]);export{xe as default};
